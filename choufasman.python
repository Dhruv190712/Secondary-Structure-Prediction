#Implementation of Chou-Fasman algorithm for secondary structure prediction
#The logic has been derived from the Class Notes and Example Provided
#The flow of the code is as follows:
#Identification of Nucleation Sites for Helices and Strands -> Extension of the Nucleation Sites -> Conflict Resolution between overlapping Helix and Strand regions

#Propensities for alpha-helix formation
Pa = {'E':1.53,'A':1.45,'L':1.34,'H':1.24,'M':1.20,'Q':1.17,'W':1.14,'V':1.14,
      'F':1.12,'K':1.07,'I':1.00,'D':0.98,'T':0.82,'S':0.79,'R':0.79,'C':0.77,
      'N':0.73,'Y':0.61,'P':0.59,'G':0.53}

#Propensities for beta-strand formation
Pb = {'M':1.67,'V':1.65,'I':1.60,'C':1.30,'Y':1.29,'F':1.28,'Q':1.23,'L':1.22,
      'T':1.20,'W':1.19,'A':0.97,'R':0.90,'G':0.81,'D':0.80,'K':0.74,'S':0.72,
      'H':0.71,'N':0.65,'P':0.62,'E':0.26}


#Check for Helix Nucleation Site (More Specifically, checks if atleast 4 out of 6 residues in the window have a Pa value greater than 1)
def chel(sam):
    count = 0 #Counter for number of residues with Pa >= 1

    for i in sam:
        if Pa[i] >= 1:
            count += 1
  
    if count >= 4 :    #Checks if atleast 4 residues have Pa >= 1
        return 1
    else:
        return 0

#Check for Strand Nucleation Site (More Specifically, checks if atleast 3 out of 5 residues in the window have a Pb value greater than 1)
def cstr(sam):
    count = 0 #Counter for number of residues with Pb >= 1

    #sum=0
    for i in sam:
        if Pb[i] >= 1:
            count += 1
    
    if  count >= 3 :    #Checks if atleast 3 residues have Pb >= 1
        return 1
    else:
        return 0

#Starts the process of checking for helices in the sample sequence
def hel(sample): 
    n = len(sample)
    hel = []
    i = 0

    while i <= n - 6:
        sam = sample[i:i+6] #Create a window of 6 residues

        if chel(sam): # Checks if the current window is a helix nucleation site
            st = i
            end = i + 6

            # Extend the window rightward if the average of 4 element/residue window is greater than 1
            while end < n:  
                n4 = sample[end-3:end+1] # Ensures that the window comprises of 3 old and one new residue
                
                if len(n4) < 4:
                    break

                total = 0
                for j in n4:
                    total += Pa[j]  #Calculate total Pa for the 4 residue window

                if total / 4 > 1: #Checks if average Pa of the 4 residue window is greater than 1
                    end += 1
 
                    if end >= n:
                        break
                else:
                    break

            # Extend the window leftward if the average of 4 element/residue window is greater than 1
            while st - 1 >= 0:  
                p4 = sample[st-1:st+3] # Ensures that the window comprises of 3 old and one new residue
                if len(p4) < 4:
                    break
                total = 0
                for m in p4:
                    total += Pa[m]  #Calculate total Pa for the 4 residue window
                
                if total / 4 > 1: #Checks if average Pa of the 4 residue window is greater than 1
                    st = st - 1
                    if st <= 0:
                        break
                else:
                    break
            
            hseq = [st, end] #Storing the indices of the identified helix
            if hseq not in hel:
                hel.append(hseq)
            i += 1
        else:
            i = i + 1

    return hel

#Starts the process of checking for strand in the sample sequence
def strand(sample): 
    l = len(sample)
    strs = []
    i = 0

    while i <= l - 5:
        sam1 = sample[i:i+5]
        if cstr(sam1):
            st = i
            end = i + 5

            # Extend the window rightward if the average of 4 element/residue window is greater than 1
            while end + 1 <= l:
                n4 = sample[end-3:end+1]  # Ensures that the window comprises of 3 old and one new residue
                if len(n4) < 4:
                    break
                
                total = sum(Pb[j] for j in n4)
    
                if total/4 > 1: #Checks if average Pb of the 4 residue window is greater than 1
                    end += 1
                else:
                    break

            while st - 1 >= 0:
                p4 = sample[st-1:st+3]
                if len(p4) < 4:
                    break
                total = sum(Pb[m] for m in p4)

                if total / 4 > 1:  #Checks if average Pb of the 4 residue window is greater than 1
                    st -= 1
                else:
                    break

            strand = [st, end]
            if strand not in strs:
                strs.append(strand)
            i = end  # jump to end to avoid overlap

        else:
            i = i + 1

    return strs


def resolve_conflicts(sample, hel, strs): #Resolve conflicts between identified helices and strands
    print("\nConflicting Segments:")

    sam1 = ["-"] * len(sample) #Initialize all residues as neither helix nor strand

    for st, end in strs: #Mark identified strands in sam1
        for i in range(st, end):
            sam1[i] = "S"

    ci = []
    for st, end in hel: #Mark identified helices in sam1
        for i in range(st, end):
            if sam1[i] == "S": # Incase of conflict, store the index for later use
                ci.append(i)
            else:
                sam1[i] = "H"

    # Resolve conflicts based on Pa vs Pb
    idx = 0
    while idx < len(ci): #Iterate through all conflicting indices
        st = ci[idx]
        seq = [st]
        idx += 1
        while idx < len(ci) and ci[idx] == seq[-1] + 1: #Identify continuous conflicting segments
            seq.append(ci[idx])
            idx += 1

        suma = sum(Pa[sample[pos]] for pos in seq)
        sumb = sum(Pb[sample[pos]] for pos in seq)

        if suma > sumb: #Assign the segment as helix or strand based on higher propensity
            for j in seq:
                sam1[j] = "H"
        else:
            for j in seq:
                sam1[j] = "S"

        for j in seq:
            print(sample[j], end="")
        print()

    return "".join(sam1)

sample = input("Enter your sample in normal text (Not FastQ):")
#sample = "MAQWNQLQQLDTRYLEQLHQLYSDSFPMELRQFLAPWIESQDWAYAASKESHATLVFHNLLGEIDQQYSRFLQESNVLYQHNLRRIKQFLQSRYLEKPMEIARIVARCLWEESRLLQTAATAAQQGGQANHPTAAVVTEKQQMLEQHLQDVRKRVQDLEQKMKVVENLQDDFDFNYKTLKSQGDMQDLNGNNQSVTRQKMQQLEQMLTALDQMRRSIVSELAGLLSAMEYVQKTLTDEELADWKRRQQIACIGGPPNICLDRLENWITSLAESQLQTRQQIKKLEELQQKVSYKGDPIVQHRPMLEERIVELFRNLMKSAFVVERQPCMPMHPDRPLVIKTGVQFTTKVRLLVKFPELNYQLKIKVCIDKDSGDVAALRGSRKFNILGTNTKVMNMEESNNGSLSAEFKHLTLREQRCGNGGRANCDASLIVTEELHLITFETEVYHQGLKIDLETHSLPVVVISNICQMPNAWASILWYNMLTNNPKNVNFFTKPPIGTWDQVAEVLSWQFSSTTKRGLSIEQLTTLAEKLLGPGVNYSGCQITWAKFCKENMAGKGFSFWVWLDNIIDLVKKYILALWNEGYIMGFISKERERAILSTKPPGTFLLRFSESSKEGGVTFTWVEKDISGKTQIQSVEPYTKQQLNNMSFAEIIMGYKIMDATNILVSPLVYLYPDIPKEEAFGKYCRPESQEHPEADPGSAAPYLKTKFICVTPTTCSNTIDLPMSPRTLDSLMQFGNNGEGAEPSAGGQFESLTFDMELTSECATSPM" 
helix_regions = hel(sample)  #Predicted helix regions
strand_regions = strand(sample) #Predicted strand regions

print("Predicted helices:")
for st, end in helix_regions:  
    print(str(st + 1) + "-" + str(end) + ":" + sample[st:end])

print("\nPredicted strands:")
for st, end in strand_regions:
    print(str(st + 1) + "-" + str(end) + ":" + sample[st:end])


str= resolve_conflicts(sample, helix_regions, strand_regions) #Resolve conflicts and get final secondary structure prediction
print("\nFinal Secondary Structure Prediction[H: Helix, S:Strand , -: Neither Helix Nor Strand]:")
print(str)